
- block:
  - name: Get instance id from metadata
    ec2_metadata_facts:

  - name: Grab ec2 data from api
    ec2_instance_facts:
      instance_ids: 
        - "{{ ansible_ec2_instance_identity_document_instanceid }}"
      aws_access_key: "{{ aws_access_key | default(omit) }}"
      aws_secret_key: "{{ aws_secret_key | default(omit) }}"
      region: "{{ aws_region }}"
    register: _internal_kubelini_worker_pki_ec2_instance_facts

  - name: Set private dns instance fact
    set_fact:
      _internal_kubelini_worker_pki_ec2_internal_dns_name: "{{_internal_kubelini_worker_pki_ec2_instance_facts['instances'][0]['private_dns_name']}}"
  when: kubelet_use_ec2_hostname | bool

- name: Copy kubernetes worker files into the bin folder
  copy:
    src: "{{ item }}"
    dest: /usr/bin/
    mode: a+x
    remote_src: yes
  with_items:
  - "/opt/kubelini/kubelet"
  - "/opt/kubelini/kube-proxy"

- name: create kubelet folders
  file:
    dest: "{{ item }}"
    state: directory
  with_items:
  - /var/lib/kubelet
  - /var/lib/kube-proxy/
  - /var/lib/kubernetes
  - /var/run/kubernetes
  - /etc/kubernetes
  - /etc/kubernetes/manifests

- name: copy cert files to kubernetes dir
  copy:
    src: "{{ item }}"
    dest: /var/lib/kubernetes/
    remote_src: yes
  with_items:
  - /opt/kubelini/ca/ca.pem
  - "/opt/kubelini/pki/{{ inventory_hostname }}.pem"
  - "/opt/kubelini/pki/{{ inventory_hostname }}-key.pem"

- name: create cni dirs
  file:
    dest: "{{ item }}"
    state: directory
  with_items:
    - /opt/cni
    - /opt/cni/bin
    - /etc/cni
    - /etc/cni/net.d

- name: download cni plugin
  get_url:
    url: "{{ cni_download_url }}"
    dest: /opt/kubelini/downloads/cni-plugins-amd64-v0.6.0.tgz

- name: unpack cni plugin
  unarchive:
    src: /opt/kubelini/downloads/cni-plugins-amd64-v0.6.0.tgz
    dest: /opt/cni/bin/
    remote_src: yes

- name: download docker
  get_url:
    url: "https://get.docker.com/builds/Linux/x86_64/docker-{{ docker_version }}.tgz"
    dest: /opt/kubelini/docker.tgz
    validate_certs: false

- name: create docker temp folder
  file:
    dest: /opt/kubelini/docker
    state: directory

- name: unpack docker
  unarchive:
    src: /opt/kubelini/docker.tgz
    dest: /opt/kubelini/docker
    remote_src: yes

- name: get docker bin files to copy
  find:
    paths: "/opt/kubelini/docker/docker"
    #recurse: yes
  register: docker_bin_files

- name: copy files to bin
  copy:
    src: "{{ item['path'] }}"
    dest: /usr/bin/
    remote_src: yes
    mode: a+x
  with_items: "{{ docker_bin_files['files'] }}"

- name: Make sure /etc/docker exists
  file:
    dest: /etc/docker
    state: directory

- name: template docker daemon.json
  template:
    src: daemon.json.j2
    dest: /etc/docker/daemon.json

- name: template docker service config
  template:
    src: docker.service.j2
    dest: /etc/systemd/system/docker.service
  notify:
  - reload docker service

#TODO: Idempodency here. Generate to a temp dir, and then compare.
- name: Generate local kubeconfig
  script: generate_node_kubeconfig.sh "{{ kubernetes_cluster_address }}"
  args:
    creates: "/opt/kubelini/{{ inventory_hostname }}.kubeconfig"
#  when: kubelet_role == 'worker'

#- name: Generate local kubeconfig
#  script: generate_node_kubeconfig.sh "127.0.0.1"
#  args:
#    creates: "/opt/kubelini/{{ inventory_hostname }}.kubeconfig"
#  when: kubelet_role == 'master'

- name: create kube-proxy bootstrap
  script: generate_kubeproxy_config.sh "{{ kubernetes_cluster_address }}"
  args:
    creates: /opt/kubelini/bootstrap_token/kube-proxy.kubeconfig
  failed_when: False

- name: copy kube-proxy bootstrap file
  copy:
    src: /opt/kubelini/bootstrap_token/kube-proxy.kubeconfig
    dest: /var/lib/kube-proxy/
    remote_src: yes

- name: template kube-proxy service config
  template:
    src: kube-proxy.service.j2
    dest: /etc/systemd/system/kube-proxy.service
  notify:
  - reload kube-proxy service

- name: start kube-proxy service
  service:
    name: kube-proxy
    state: started

- name: Copy the kubelet kubeconfig file
  copy:
    src: "/opt/kubelini/{{ inventory_hostname }}.kubeconfig"
    dest: "/var/lib/kubelet/{{ inventory_hostname }}.kubeconfig"
    remote_src: yes

- name: Flatten kubelet_node_labels into comma-separated list
  set_fact:
    _internal_node_labels_list: "{{ kubelet_node_labels | join(',')}}"

- name: template kubelet service config
  template:
    src: kubelet.service.j2
    dest: /etc/systemd/system/kubelet.service
  notify:
  - reload kubelet service

- name: start kubelet service
  service:
    name: kubelet
    state: started